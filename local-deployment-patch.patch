diff --git a/internal/config/config.go b/internal/config/config.go
index 571ef30..dbfa775 100644
--- a/internal/config/config.go
+++ b/internal/config/config.go
@@ -242,7 +242,7 @@ func DefaultConfig() *Config {
 		Server: Server{
 			HTTP: HTTP{
 				Enabled: true,
-				Port:    "3476",
+				Port:    "3477",
 				TLSConfig: TLSConfig{
 					Enabled: false,
 				},
@@ -250,12 +250,12 @@ func DefaultConfig() *Config {
 				CORSAllowedHeaders: []string{"*"},
 			},
 			GRPC: GRPC{
-				Port: "3478",
+				Port: "3479",
 				TLSConfig: TLSConfig{
 					Enabled: false,
 				},
 			},
-			RateLimit: 100,
+			RateLimit: 1000,
 		},
 		Profiler: Profiler{
 			Enabled: false,
@@ -305,7 +305,10 @@ func DefaultConfig() *Config {
 			},
 		},
 		Distributed: Distributed{
-			Enabled: false,
+			Enabled:  true,
+			Protocol: "serf",
+			NodeName: "permify2",
+			Node:     "localhost:7946",
 		},
 	}
 }
diff --git a/internal/engines/consistent/hashring.go b/internal/engines/consistent/hashring.go
index b6fb9d3..053b2b2 100644
--- a/internal/engines/consistent/hashring.go
+++ b/internal/engines/consistent/hashring.go
@@ -45,13 +45,16 @@ func NewCheckEngineWithHashring(checker invoke.Check, consistent *hash.Consisten
 }
 
 func (c *Hashring) Check(ctx context.Context, request *base.PermissionCheckRequest) (response *base.PermissionCheckResponse, err error) {
+	c.l.Info("******* , check")
 	// Generate a unique checkKey string based on the provided PermissionCheckRequest
 	k := fmt.Sprintf("check_%s_%s:%s:%s@%s", request.GetTenantId(), request.GetMetadata().GetSchemaVersion(), request.GetMetadata().GetSnapToken(), tuple.EntityAndRelationToString(&base.EntityAndRelation{
 		Entity:   request.GetEntity(),
 		Relation: request.GetPermission(),
 	}), tuple.SubjectToString(request.GetSubject()))
 
+	c.l.Info("before consistent.Get")
 	_, _, ok := c.consistent.Get(k)
+	c.l.Info("after consistent.Get", ok)
 	if !ok {
 		ok := c.consistent.AddKey(k)
 		if !ok {
@@ -65,8 +68,14 @@ func (c *Hashring) Check(ctx context.Context, request *base.PermissionCheckReque
 		}
 		c.l.Info("added key %s to consistent hash", k)
 	}
+	c.l.Info("after !ok ....")
 
 	node, conn, found := c.consistent.Get(k)
+	//node = "192.168.43.2:3478"
+	//conn = c.consistent.GetStaticNode(node)
+	//found = true
+
+	c.l.Info("after consistent.Get2 ...", node, conn, found)
 	if !found {
 		// If the responsible node is not found, return false
 		return &base.PermissionCheckResponse{
@@ -76,13 +85,17 @@ func (c *Hashring) Check(ctx context.Context, request *base.PermissionCheckReque
 			},
 		}, errors.New("node not found to key")
 	}
+	c.l.Info("after !found")
 
+	fmt.Println("********* localNodeAddress ", c.localNodeAddress)
 	if node == c.localNodeAddress {
 		// Get the value from the cache using the generated cache key
 		return c.checker.Check(ctx, request)
 	}
 
+	fmt.Println("want to forward request to another node node,conn,request: ", node, conn, request)
 	resp, err := c.forwardRequestToNode(ctx, conn, request)
+	fmt.Println("after forwarding request, resp: ", resp, err)
 	if err != nil {
 		return &base.PermissionCheckResponse{
 			Can: base.CheckResult_RESULT_DENIED,
diff --git a/internal/storage/migration.go b/internal/storage/migration.go
index 27bc4ee..e1e0c4b 100644
--- a/internal/storage/migration.go
+++ b/internal/storage/migration.go
@@ -43,8 +43,10 @@ func Migrate(conf config.Database, l logger.Interface) (err error) {
 		}
 
 		goose.SetBaseFS(postgresMigrations)
+		l.Info("migrationdir", postgresMigrationDir)
 
 		if err = goose.Up(db, postgresMigrationDir); err != nil {
+			l.Fatal("migration failed", postgresMigrationDir, err)
 			return err
 		}
 
diff --git a/internal/storage/postgres/migrations/20230117143902_initial.sql b/internal/storage/postgres/migrations/20230117143902_initial.sql
index 3e15a92..b147dec 100644
--- a/internal/storage/postgres/migrations/20230117143902_initial.sql
+++ b/internal/storage/postgres/migrations/20230117143902_initial.sql
@@ -1,3 +1,4 @@
+
 -- +goose Up
 CREATE TABLE IF NOT EXISTS relation_tuples (
     id               SERIAL  NOT NULL,
diff --git a/pkg/cmd/serve.go b/pkg/cmd/serve.go
index f023a53..c3df3d0 100644
--- a/pkg/cmd/serve.go
+++ b/pkg/cmd/serve.go
@@ -93,6 +93,7 @@ func serve() func(cmd *cobra.Command, args []string) error {
 
 		// Run database migration if enabled
 		if cfg.AutoMigrate {
+			l.Info("auto migration")
 			err = storage.Migrate(cfg.Database, l)
 			if err != nil {
 				l.Fatal("failed to migrate database: %w", err)
@@ -100,6 +101,7 @@ func serve() func(cmd *cobra.Command, args []string) error {
 		}
 
 		// Initialize database
+		l.Info("connecting to database")
 		db, err := factories.DatabaseFactory(cfg.Database)
 		if err != nil {
 			l.Fatal("failed to initialize database: %w", err)
diff --git a/pkg/consistent/consistent.go b/pkg/consistent/consistent.go
index 822af35..59524d9 100644
--- a/pkg/consistent/consistent.go
+++ b/pkg/consistent/consistent.go
@@ -34,6 +34,7 @@ type Consistent interface {
 	Get(v string) (string, *grpc.ClientConn, bool)
 	Remove(node string) error
 	AddKey(key string) bool
+	GetStaticNode(node string) *grpc.ClientConn
 }
 
 // ConsistentHash implements a consistent hashing ring
@@ -243,11 +244,18 @@ func (h *ConsistentHash) containsNode(node string) bool {
 	_, exists := h.Nodes[node]
 	return exists
 }
+func (h *ConsistentHash) GetStaticNode(node string) *grpc.ClientConn {
+	for s, _ := range h.Nodes {
+		fmt.Println("getting all nodes: ", s)
+	}
+	return h.Nodes[node]
+}
 
 // addNode adds a node to the ring by creating a gRPC connection to it
 func (h *ConsistentHash) addNode(node string) error {
-	conn, err := grpc.Dial(node, h.connectionOptions...)
+	conn, err := grpc.Dial(node, grpc.WithInsecure())
 	if err != nil {
+		fmt.Println("addNodeError", node, h.connectionOptions)
 		return fmt.Errorf("failed to dial: %w", err)
 	}
 	h.Nodes[node] = conn
diff --git a/pkg/gossip/serf.go b/pkg/gossip/serf.go
index 1b99bf8..456a9de 100644
--- a/pkg/gossip/serf.go
+++ b/pkg/gossip/serf.go
@@ -23,6 +23,8 @@ type Serf struct {
 func NewSerfGossip(node string) (*Serf, error) {
 	// Getting the default serf configuration
 	config := serf.DefaultConfig()
+	config.MemberlistConfig.BindPort = 7948
+	config.NodeName = "node1"
 
 	// This makes sure that the node re-joins the cluster even after it leaves
 	config.RejoinAfterLeave = true
@@ -72,11 +74,21 @@ func (s *Serf) SyncNodes(ctx context.Context, consistent *hash.ConsistentHash, n
 			case serf.EventMemberJoin: // If a new node has joined the cluster...
 				me := e.(serf.MemberEvent)
 				for _, m := range me.Members {
+					if m.Name == "agent_one" {
+						continue
+					}
+					//fmt.Println("%%%%% adding members", m.Addr.String(), m.Port)
 					if m.Name != nodeName { // And the node is not the current node...
 						if _, exists := consistent.Nodes[fmt.Sprintf("%s:%d", m.Addr.String(), m.Port)]; !exists {
-							fmt.Printf("Adding node %s:%s to the consistent hash\n", m.Addr.String(), port)
+							fmt.Printf("Adding node %s:%s to the consistent hash\n", m.Addr.String(), m.Port)
 							// Add the new node to the consistent hash.
-							if err := consistent.AddWithWeight(fmt.Sprintf("%s:%s", m.Addr.String(), port), 100); err != nil {
+							var customPort = 0
+							if m.Name == "node2" {
+								customPort = 3478
+							} else if m.Name == "node1" {
+								customPort = 3479
+							}
+							if err := consistent.AddWithWeight(fmt.Sprintf("%s:%d", m.Addr.String(), customPort), 1); err != nil {
 								fmt.Printf("error adding node %s:%d to the consistent hash: %v\n", m.Addr.String(), m.Port, err)
 								// If there was an error adding the node, log the error and continue to the next node.
 								continue
@@ -91,8 +103,14 @@ func (s *Serf) SyncNodes(ctx context.Context, consistent *hash.ConsistentHash, n
 						fmt.Printf("Removing node %s:%d to the consistent hash\n", m.Addr.String(), m.Port)
 						if _, exists := consistent.Nodes[fmt.Sprintf("%s:%d", m.Addr.String(), m.Port)]; exists {
 							// Remove the node from the consistent hash.
-							if err := consistent.Remove(fmt.Sprintf("%s:%s", m.Addr.String(), port)); err != nil {
-								fmt.Printf("Error removing node %s:%d from the consistent hash: %v\n", m.Addr.String(), m.Port, err)
+							var customPort = 0
+							if m.Name == "node2" {
+								customPort = 3478
+							} else if m.Name == "node1" {
+								customPort = 3479
+							}
+							if err := consistent.Remove(fmt.Sprintf("%s:%d", m.Addr.String(), customPort)); err != nil {
+								fmt.Printf("Error removing node %s:%d from the consistent hash: %v\n", m.Addr.String(), customPort, err)
 								// If there was an error removing the node, log the error and continue to the next node.
 								continue
 							}
